diff --git a/llama.cpp/ggml/src/ggml.c b/ggml/src/ggml.c
index 86f1c31af..1072c0b96 100644
--- a/llama.cpp/ggml/src/ggml.c
+++ b/llama.cpp/ggml/src/ggml.c
@@ -555,8 +555,8 @@ static wchar_t * ggml_mbstowcs(const char * mbs) {
 }
 #endif
 
-FILE * ggml_fopen(const char * fname, const char * mode) {
 #ifdef _WIN32
+FILE * ggml_fopen(const char * fname, const char * mode) {
     FILE * file = NULL;
 
     // convert fname (UTF-8)
@@ -577,11 +577,33 @@ FILE * ggml_fopen(const char * fname, const char * mode) {
     }
 
     return file;
+}
 #else
+typedef struct {
+    const void * buf;
+    size_t       size;
+} ggml_memory_file_t;
+
+ggml_memory_file_t g_memory_file = {0};
+
+void ggml_set_memory_buffer(const void * buf, size_t size) {
+    g_memory_file.buf = buf;
+    g_memory_file.size = size;
+}
+
+FILE * ggml_fopen(const char * fname, const char * mode) {
+    const char * memory_magic_prefix = "memory:";
+    if (g_memory_file.buf != NULL && strncmp(fname, memory_magic_prefix, strlen(memory_magic_prefix)) == 0) {
+        FILE* result = fmemopen((void *)g_memory_file.buf, g_memory_file.size, mode);
+        if (result == NULL) {
+            printf("fmemopen failed: %s\n", strerror(errno));
+        }
+        return result;
+    }
     return fopen(fname, mode);
+}
 #endif
 
-}
 
 static const struct ggml_type_traits type_traits[GGML_TYPE_COUNT] = {
     [GGML_TYPE_I8] = {
